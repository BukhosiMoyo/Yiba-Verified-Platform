generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Institution {
  institution_id      String          @id @default(uuid())
  legal_name          String
  trading_name        String?
  institution_type    InstitutionType
  registration_number String
  tax_compliance_pin  String?
  physical_address    String
  postal_address      String?
  province            String
  delivery_modes      DeliveryMode[]
  status              RecordStatus    @default(DRAFT)
  contact_person_name String?
  contact_email       String?
  contact_number      String?
  created_at          DateTime        @default(now())
  updated_at          DateTime        @updatedAt
  deleted_at          DateTime?
  auditLogs           AuditLog[]      @relation("InstitutionAuditLogs")
  documents           Document[]      @relation("DocumentInstitution")
  enrolments          Enrolment[]
  learners            Learner[]
  readinessRecords    Readiness[]
  users               User[]
  submissions         Submission[]
  qctoRequests        QCTORequest[]
  invites             Invite[]

  @@index([registration_number])
  @@index([province])
}

model User {
  user_id                  String                    @id @default(uuid())
  institution_id           String?
  role                     UserRole
  first_name               String
  last_name                String
  email                    String                    @unique
  emailVerified            DateTime?
  phone                    String?
  password_hash            String?
  status                   String                    @default("ACTIVE")
  image                    String?
  created_at               DateTime                  @default(now())
  updated_at               DateTime                  @updatedAt
  deleted_at               DateTime?
  accounts                 Account[]
  auditLogs                AuditLog[]                @relation("AuditChangedBy")
  uploadedDocuments        Document[]                @relation("UserUploadedDocuments")
  evidenceFlags            EvidenceFlag[]            @relation("EvidenceFlaggedBy")
  evidenceResolved         EvidenceFlag[]            @relation("EvidenceResolvedBy")
  learner                  Learner?                  @relation("StudentLearner")
  readinessRecommendations ReadinessRecommendation[] @relation("ReadinessRecommendedBy")
  reviewComments           ReviewComment[]           @relation("ReviewCommentsBy")
  notifications            Notification[]            @relation("UserNotifications")
  announcements            Announcement[]            @relation("UserAnnouncements")
  sessions                 Session[]
  institution              Institution?              @relation(fields: [institution_id], references: [institution_id])
  submittedSubmissions     Submission[]              @relation("UserSubmitted")
  reviewedSubmissions      Submission[]              @relation("UserReviewed")
  addedResources              SubmissionResource[]           @relation("UserAddedResource")
  reviewAttachmentsUploaded   SubmissionReviewAttachment[]   @relation("UserUploadedReviewAttachments")
  requestedQCTORequests       QCTORequest[]                  @relation("QCTORequested")
  reviewedQCTORequests     QCTORequest[]             @relation("InstitutionReviewed")
  createdInvites           Invite[]                  @relation("UserCreatedInvites")

  @@index([institution_id])
  @@index([role])
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [user_id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [user_id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Readiness {
  readiness_id        String          @id @default(uuid())
  institution_id      String
  qualification_title String
  saqa_id             String
  nqf_level           Int?
  curriculum_code     String
  delivery_mode       DeliveryMode
  readiness_status    ReadinessStatus @default(NOT_STARTED)
  submission_date     DateTime?
  created_at          DateTime        @default(now())
  updated_at          DateTime        @updatedAt
  deleted_at          DateTime?

  // Section 1: Qualification Information (above fields)

  // Section 2: Self-Assessment
  self_assessment_completed Boolean?
  self_assessment_remarks   String?  @db.Text

  // Section 3: Registration & Legal Compliance
  registration_type              String?
  professional_body_registration Boolean?

  // Section 4: Infrastructure & Physical Resources
  training_site_address     String? @db.Text
  ownership_type            String?
  number_of_training_rooms  Int?
  room_capacity             Int?
  facilitator_learner_ratio String?

  // Section 5: Learning Material Alignment
  learning_material_exists       Boolean?
  knowledge_module_coverage      Int? // Percentage
  practical_module_coverage      Int? // Percentage
  curriculum_alignment_confirmed Boolean?

  // Section 6: Occupational Health & Safety (OHS)
  fire_extinguisher_available    Boolean?
  fire_extinguisher_service_date DateTime?
  emergency_exits_marked         Boolean?
  accessibility_for_disabilities Boolean?
  first_aid_kit_available        Boolean?
  ohs_representative_name        String?

  // Section 7: LMS & Online Delivery Capability
  lms_name                      String?
  max_learner_capacity          Int?
  internet_connectivity_method  String?
  isp                           String?
  backup_frequency              String?
  data_storage_description      String? @db.Text
  security_measures_description String? @db.Text

  // Section 8: Workplace-Based Learning (WBL)
  wbl_workplace_partner_name      String?
  wbl_agreement_type              String?
  wbl_agreement_duration          String?
  wbl_components_covered          String? @db.Text
  wbl_learner_support_description String? @db.Text
  wbl_assessment_responsibility   String?

  // Section 9: Policies & Procedures (simplified - full implementation would need Policy model)
  // For MVP, we'll note that policy documents should be uploaded via Documents section
  // with appropriate categorization. Full policy management can be added in V2.
  policies_procedures_notes String? @db.Text

  // Section 10: Human Resources (Facilitators) - simplified
  // Full implementation would need Facilitator model with table management
  // For MVP, noting that facilitator information can be stored separately
  // and linked via Documents or in a future Facilitator model
  facilitators_notes String? @db.Text

  documents      Document[]               @relation("DocumentReadiness")
  institution    Institution              @relation(fields: [institution_id], references: [institution_id])
  recommendation ReadinessRecommendation?

  @@index([institution_id])
  @@index([saqa_id])
  @@index([readiness_status])
}

model Learner {
  learner_id         String      @id @default(uuid())
  institution_id     String
  user_id            String?     @unique
  national_id        String      @unique
  alternate_id       String?
  first_name         String
  last_name          String
  birth_date         DateTime
  gender_code        String
  nationality_code   String
  home_language_code String?
  disability_status  String?
  popia_consent      Boolean
  consent_date       DateTime
  created_at         DateTime    @default(now())
  updated_at         DateTime    @updatedAt
  deleted_at         DateTime?
  documents          Document[]  @relation("DocumentLearner")
  enrolments         Enrolment[]
  institution        Institution @relation(fields: [institution_id], references: [institution_id])
  user               User?       @relation("StudentLearner", fields: [user_id], references: [user_id])

  @@index([institution_id])
  @@index([national_id])
  @@index([user_id])
}

model Qualification {
  qualification_id String      @id @default(uuid())
  name             String
  code             String?
  created_at       DateTime    @default(now())
  updated_at       DateTime    @updatedAt
  deleted_at       DateTime?
  enrolments       Enrolment[]

  @@index([code])
}

model Enrolment {
  enrolment_id             String          @id @default(uuid())
  learner_id               String
  institution_id           String
  qualification_id         String? // New FK (optional for backward compatibility)
  qualification_title      String // Keep for backward compatibility
  start_date               DateTime
  expected_completion_date DateTime?
  enrolment_status         EnrolmentStatus @default(ACTIVE)
  attendance_percentage    Decimal?        @db.Decimal(5, 2)
  assessment_centre_code   String?
  readiness_status         String?
  flc_status               String?
  statement_number         String?
  created_at               DateTime        @default(now())
  updated_at               DateTime        @updatedAt
  deleted_at               DateTime?
  documents                Document[]      @relation("DocumentEnrolment")
  institution              Institution     @relation(fields: [institution_id], references: [institution_id])
  learner                  Learner         @relation(fields: [learner_id], references: [learner_id])
  qualification            Qualification?  @relation(fields: [qualification_id], references: [qualification_id])

  @@index([institution_id])
  @@index([learner_id])
  @@index([enrolment_status])
  @@index([qualification_id])
}

model Document {
  document_id       String                @id @default(uuid())
  related_entity    DocumentRelatedEntity
  related_entity_id String
  document_type     String
  file_name         String
  version           Int
  status            DocumentStatus        @default(UPLOADED)
  uploaded_by       String
  uploaded_at       DateTime              @default(now())
  storage_key       String?
  mime_type         String?
  file_size_bytes   Int?
  uploadedByUser    User                  @relation("UserUploadedDocuments", fields: [uploaded_by], references: [user_id])
  enrolment         Enrolment?            @relation("DocumentEnrolment", fields: [related_entity_id], references: [enrolment_id], map: "fk_doc_enrolment")
  institution       Institution?          @relation("DocumentInstitution", fields: [related_entity_id], references: [institution_id], map: "fk_doc_institution")
  learner           Learner?              @relation("DocumentLearner", fields: [related_entity_id], references: [learner_id], map: "fk_doc_learner")
  readiness         Readiness?            @relation("DocumentReadiness", fields: [related_entity_id], references: [readiness_id], map: "fk_doc_readiness")
  flags             EvidenceFlag[]

  @@index([related_entity, related_entity_id])
  @@index([uploaded_by])
}

model AuditLog {
  audit_id                String          @id @default(uuid())
  entity_type             AuditEntityType
  entity_id               String
  field_name              String
  old_value               String?
  new_value               String?
  changed_by              String
  role_at_time            UserRole
  changed_at              DateTime        @default(now())
  reason                  String?
  institution_id          String?
  change_type             AuditChangeType
  related_submission_id   String? // Links to Submission.submission_id (for institution submissions)
  related_qcto_request_id String? // Links to QCTORequest.request_id (for QCTO requests)
  changedBy               User            @relation("AuditChangedBy", fields: [changed_by], references: [user_id])
  institution             Institution?    @relation("InstitutionAuditLogs", fields: [institution_id], references: [institution_id])
  relatedSubmission       Submission?     @relation("SubmissionAuditLogs", fields: [related_submission_id], references: [submission_id], map: "fk_audit_submission")
  relatedQCTORequest      QCTORequest?    @relation("QCTORequestAuditLogs", fields: [related_qcto_request_id], references: [request_id], map: "fk_audit_qcto_request")

  @@index([entity_type, entity_id])
  @@index([changed_by])
  @@index([changed_at])
  @@index([institution_id])
}

model EvidenceFlag {
  flag_id        String    @id @default(uuid())
  document_id    String
  flagged_by     String
  reason         String
  status         String    @default("ACTIVE")
  created_at     DateTime  @default(now())
  resolved_at    DateTime?
  resolved_by    String?
  document       Document  @relation(fields: [document_id], references: [document_id])
  flaggedByUser  User      @relation("EvidenceFlaggedBy", fields: [flagged_by], references: [user_id])
  resolvedByUser User?     @relation("EvidenceResolvedBy", fields: [resolved_by], references: [user_id])

  @@index([document_id])
  @@index([flagged_by])
  @@index([status])
}

model ReviewComment {
  comment_id        String   @id @default(uuid())
  related_entity    String
  related_entity_id String
  comment_by        String
  comment_text      String
  is_internal       Boolean  @default(false)
  created_at        DateTime @default(now())
  updated_at        DateTime @updatedAt
  commentByUser     User     @relation("ReviewCommentsBy", fields: [comment_by], references: [user_id])

  @@index([related_entity, related_entity_id])
  @@index([comment_by])
  @@index([created_at])
}

model ReadinessRecommendation {
  recommendation_id String    @id @default(uuid())
  readiness_id      String    @unique
  recommended_by    String
  recommendation    String
  remarks           String?
  created_at        DateTime  @default(now())
  updated_at        DateTime  @updatedAt
  readiness         Readiness @relation(fields: [readiness_id], references: [readiness_id])
  recommendedByUser User      @relation("ReadinessRecommendedBy", fields: [recommended_by], references: [user_id])

  @@index([readiness_id])
  @@index([recommended_by])
  @@index([recommendation])
}

/**
 * Submission (Compliance Pack)
 * Tracks what institutions submit/share with QCTO.
 * Supports submission-based QCTO access: QCTO can only view resources linked to submissions.
 * Workflow:
 * - Institution creates submission (status: DRAFT)
 * - Institution adds resources (readiness, documents, learners, enrolments) to submission
 * - Institution submits to QCTO (status: SUBMITTED)
 * - QCTO reviews (status: UNDER_REVIEW)
 * - QCTO approves/rejects/requests corrections (status: APPROVED / REJECTED / RETURNED_FOR_CORRECTION)
 */
model Submission {
  submission_id   String           @id @default(uuid())
  institution_id  String
  title           String? // Optional title/description
  submission_type String? // e.g., "READINESS", "COMPLIANCE_PACK", "ANNUAL_REPORT"
  status          SubmissionStatus @default(DRAFT)
  submitted_at    DateTime?
  submitted_by    String? // Institution user who submitted
  reviewed_at     DateTime?
  reviewed_by     String? // QCTO user who reviewed
  review_notes    String?
  created_at      DateTime         @default(now())
  updated_at      DateTime         @updatedAt
  deleted_at      DateTime?

  // Relations
  institution            Institution                   @relation(fields: [institution_id], references: [institution_id])
  submittedByUser        User?                         @relation("UserSubmitted", fields: [submitted_by], references: [user_id])
  reviewedByUser         User?                         @relation("UserReviewed", fields: [reviewed_by], references: [user_id])
  submissionResources    SubmissionResource[]
  reviewAttachments      SubmissionReviewAttachment[]
  auditLogs              AuditLog[]                    @relation("SubmissionAuditLogs")

  @@index([institution_id])
  @@index([status])
  @@index([submitted_at])
  @@index([submitted_by])
  @@index([reviewed_by])
}

/**
 * SubmissionResource
 * Links resources (readiness, documents, learners, enrolments) to submissions.
 * This is how we track what QCTO can see - only resources linked to approved/submitted submissions.
 */
model SubmissionResource {
  resource_id       String                 @id @default(uuid())
  submission_id     String
  resource_type     SubmissionResourceType
  resource_id_value String // The actual ID of the resource (readiness_id, learner_id, etc.)
  added_at          DateTime               @default(now())
  added_by          String
  notes             String?

  // Relations
  submission  Submission @relation(fields: [submission_id], references: [submission_id], onDelete: Cascade)
  addedByUser User       @relation("UserAddedResource", fields: [added_by], references: [user_id])

  @@unique([submission_id, resource_type, resource_id_value])
  @@index([submission_id])
  @@index([resource_type, resource_id_value])
  @@index([added_by])
}

/// Attachments added by QCTO reviewers to Review Notes (e.g. supporting docs, screenshots).
model SubmissionReviewAttachment {
  attachment_id   String   @id @default(uuid())
  submission_id   String
  file_name       String
  storage_key     String
  mime_type       String?
  file_size_bytes Int?
  uploaded_by     String
  uploaded_at     DateTime @default(now())

  submission      Submission @relation(fields: [submission_id], references: [submission_id], onDelete: Cascade)
  uploadedByUser  User       @relation("UserUploadedReviewAttachments", fields: [uploaded_by], references: [user_id])

  @@index([submission_id])
}

/**
 * QCTORequest
 * Tracks QCTO requests to institutions for specific data/information.
 * Supports request-based QCTO access: Institutions approve requests, which grants QCTO access to requested resources.
 * Workflow:
 * - QCTO creates request (status: PENDING)
 * - Institution reviews request
 * - Institution approves/rejects (status: APPROVED / REJECTED)
 * - If approved, QCTO can access requested resources
 */
model QCTORequest {
  request_id     String            @id @default(uuid())
  institution_id String
  requested_by   String // QCTO user who requested
  request_type   String? // e.g., "READINESS_REVIEW", "COMPLIANCE_CHECK", "DATA_EXPORT"
  title          String
  description    String?
  status         QCTORequestStatus @default(PENDING)
  requested_at   DateTime          @default(now())
  reviewed_at    DateTime? // When institution reviewed the request
  reviewed_by    String? // Institution user who reviewed
  response_notes String?
  expires_at     DateTime? // Optional expiration date
  created_at     DateTime          @default(now())
  updated_at     DateTime          @updatedAt
  deleted_at     DateTime?

  // Relations
  institution      Institution           @relation(fields: [institution_id], references: [institution_id])
  requestedByUser  User                  @relation("QCTORequested", fields: [requested_by], references: [user_id])
  reviewedByUser   User?                 @relation("InstitutionReviewed", fields: [reviewed_by], references: [user_id])
  requestResources QCTORequestResource[]
  auditLogs        AuditLog[]            @relation("QCTORequestAuditLogs")

  @@index([institution_id])
  @@index([requested_by])
  @@index([status])
  @@index([requested_at])
  @@index([reviewed_by])
}

/**
 * QCTORequestResource
 * Links resources to QCTO requests (what QCTO is requesting access to).
 * Once request is APPROVED, QCTO can view these resources.
 */
model QCTORequestResource {
  resource_id       String                 @id @default(uuid())
  request_id        String
  resource_type     SubmissionResourceType
  resource_id_value String // The actual ID of the resource (readiness_id, learner_id, etc.)
  added_at          DateTime               @default(now())
  notes             String?

  // Relations
  request QCTORequest @relation(fields: [request_id], references: [request_id], onDelete: Cascade)

  @@unique([request_id, resource_type, resource_id_value])
  @@index([request_id])
  @@index([resource_type, resource_id_value])
}

enum UserRole {
  PLATFORM_ADMIN
  QCTO_USER
  INSTITUTION_ADMIN
  INSTITUTION_STAFF
  STUDENT
}

enum InviteStatus {
  QUEUED
  SENDING
  SENT
  DELIVERED
  OPENED
  ACCEPTED
  FAILED
  RETRYING
  EXPIRED
}

model Invite {
  invite_id          String    @id @default(uuid())
  email              String
  role               UserRole
  institution_id     String?
  token_hash         String    @unique
  expires_at         DateTime
  used_at            DateTime?
  created_by_user_id String
  created_at         DateTime  @default(now())
  updated_at         DateTime  @updatedAt
  deleted_at         DateTime?

  // Smart bulk invite system fields
  status          InviteStatus @default(QUEUED)
  attempts        Int          @default(0)
  max_attempts    Int          @default(3)
  last_attempt_at DateTime?
  sent_at         DateTime?
  delivered_at    DateTime?
  opened_at       DateTime?
  clicked_at      DateTime?
  accepted_at     DateTime?
  failure_reason  String?      @db.Text
  retry_count     Int          @default(0)
  next_retry_at   DateTime?
  batch_id        String? // For grouping bulk invites

  // Relations
  createdBy   User         @relation("UserCreatedInvites", fields: [created_by_user_id], references: [user_id])
  institution Institution? @relation(fields: [institution_id], references: [institution_id])

  @@index([email])
  @@index([institution_id])
  @@index([expires_at])
  @@index([token_hash])
  @@index([created_by_user_id])
  @@index([status])
  @@index([batch_id])
  @@index([next_retry_at])
}

enum RecordStatus {
  DRAFT
  APPROVED
  SUSPENDED
}

enum InstitutionType {
  TVET
  PRIVATE_SDP
  NGO
  UNIVERSITY
  OTHER
}

enum DeliveryMode {
  FACE_TO_FACE
  BLENDED
  MOBILE
}

enum ReadinessStatus {
  NOT_STARTED
  IN_PROGRESS
  SUBMITTED
  UNDER_REVIEW
  RETURNED_FOR_CORRECTION
  REVIEWED
  RECOMMENDED
  REJECTED
}

/**
 * Notification
 * User notifications for system events and status changes.
 * Supports notification types: submission_reviewed, request_approved, readiness_reviewed, etc.
 */
model Notification {
  notification_id   String           @id @default(uuid())
  user_id           String
  notification_type NotificationType
  title             String
  message           String           @db.Text
  entity_type       String? // e.g., "SUBMISSION", "QCTO_REQUEST", "READINESS"
  entity_id         String?
  is_read           Boolean          @default(false)
  read_at           DateTime?
  created_at        DateTime         @default(now())
  user              User             @relation("UserNotifications", fields: [user_id], references: [user_id])

  @@index([user_id])
  @@index([is_read])
  @@index([created_at])
  @@index([notification_type])
}

enum NotificationType {
  SUBMISSION_REVIEWED
  SUBMISSION_APPROVED
  SUBMISSION_REJECTED
  REQUEST_APPROVED
  REQUEST_REJECTED
  READINESS_REVIEWED
  READINESS_RECOMMENDED
  READINESS_REJECTED
  DOCUMENT_FLAGGED
  SYSTEM_ALERT
}

/**
 * Announcement
 * System-wide announcements created by platform admins and visible to all users.
 * Supports priority levels and expiration dates.
 */
model Announcement {
  announcement_id String               @id @default(uuid())
  title           String
  message         String               @db.Text
  priority        AnnouncementPriority @default(MEDIUM)
  status          AnnouncementStatus   @default(ACTIVE)
  created_by      String
  expires_at      DateTime?
  created_at      DateTime             @default(now())
  updated_at      DateTime             @updatedAt
  deleted_at      DateTime?
  createdByUser   User                 @relation("UserAnnouncements", fields: [created_by], references: [user_id])

  @@index([status])
  @@index([created_at])
  @@index([expires_at])
  @@index([created_by])
}

enum AnnouncementPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum AnnouncementStatus {
  ACTIVE
  ARCHIVED
}

enum EnrolmentStatus {
  ACTIVE
  COMPLETED
  TRANSFERRED
  ARCHIVED
}

enum DocumentRelatedEntity {
  INSTITUTION
  LEARNER
  READINESS
  ENROLMENT
}

enum AuditEntityType {
  INSTITUTION
  USER
  LEARNER
  ENROLMENT
  READINESS
  DOCUMENT
}

enum DocumentStatus {
  UPLOADED
  FLAGGED
  ACCEPTED
}

enum AuditChangeType {
  CREATE
  UPDATE
  DELETE
  STATUS_CHANGE
}

enum SubmissionStatus {
  DRAFT
  SUBMITTED
  UNDER_REVIEW
  APPROVED
  REJECTED
  RETURNED_FOR_CORRECTION
}

enum QCTORequestStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
  WITHDRAWN
}

enum SubmissionResourceType {
  READINESS
  LEARNER
  ENROLMENT
  DOCUMENT
  INSTITUTION
}

